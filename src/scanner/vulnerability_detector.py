import json
import logging
import requests
import time
import re
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import os

class VulnerabilityDetector:
    def __init__(self, database_manager):
        self.logger = logging.getLogger(__name__)
        self.db_manager = database_manager
        
        # Load vulnerability signatures and patterns
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.service_vulnerabilities = self._load_service_vulnerabilities()
        
        # CVE API configuration
        self.cve_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.last_api_call = 0
        self.api_rate_limit = 0.6  # Rate limit for NIST API (10 requests per minute)
        
        # Local CVE database cache
        self.cve_cache_file = os.path.join(
            os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 
            'data', 'cve_cache.json'
        )
        self._ensure_data_directory()
    
    def _ensure_data_directory(self):
        data_dir = os.path.dirname(self.cve_cache_file)
        os.makedirs(data_dir, exist_ok=True)
        
        # Create default vulnerability patterns if not exists
        patterns_file = os.path.join(data_dir, 'vulnerability_patterns.json')
        if not os.path.exists(patterns_file):
            self._create_default_patterns(patterns_file)
    
    def _create_default_patterns(self, patterns_file: str):
        default_patterns = {
            "ssh": [
                {
                    "pattern": r"OpenSSH (\d+\.\d+)",
                    "version_check": "version_less_than",
                    "vulnerable_versions": {
                        "7.4": ["CVE-2016-10009", "CVE-2016-10010", "CVE-2016-10011", "CVE-2016-10012"],
                        "8.3": ["CVE-2020-14145"],
                        "8.5": ["CVE-2021-41617"]
                    }
                }
            ],
            "http": [
                {
                    "pattern": r"Apache httpd (\d+\.\d+\.\d+)",
                    "version_check": "version_range",
                    "vulnerable_versions": {
                        "2.4.49": ["CVE-2021-41773", "CVE-2021-42013"],
                        "2.4.50": ["CVE-2021-44790"],
                        "2.4.51": ["CVE-2022-22719", "CVE-2022-22720", "CVE-2022-22721"]
                    }
                },
                {
                    "pattern": r"nginx/(\d+\.\d+\.\d+)",
                    "version_check": "version_less_than",
                    "vulnerable_versions": {
                        "1.20.1": ["CVE-2021-23017"],
                        "1.21.0": ["CVE-2021-23017"]
                    }
                }
            ],
            "ftp": [
                {
                    "pattern": r"vsftpd (\d+\.\d+\.\d+)",
                    "version_check": "exact_match",
                    "vulnerable_versions": {
                        "2.3.4": ["CVE-2011-2523"]
                    }
                }
            ],
            "smb": [
                {
                    "pattern": r"Samba (\d+\.\d+\.\d+)",
                    "version_check": "version_range",
                    "vulnerable_versions": {
                        "4.5.16": ["CVE-2018-1050", "CVE-2018-1057"],
                        "4.7.6": ["CVE-2018-1139"],
                        "4.8.12": ["CVE-2019-14833"]
                    }
                }
            ],
            "ssl": [
                {
                    "pattern": r"OpenSSL (\d+\.\d+\.\d+[a-z]?)",
                    "version_check": "version_less_than",
                    "vulnerable_versions": {
                        "1.0.2ze": ["CVE-2020-1967"],
                        "1.1.1l": ["CVE-2021-3711", "CVE-2021-3712"],
                        "3.0.2": ["CVE-2022-0778"]
                    }
                }
            ]
        }
        
        try:
            with open(patterns_file, 'w') as f:
                json.dump(default_patterns, f, indent=2)
            self.logger.info("Created default vulnerability patterns")
        except Exception as e:
            self.logger.error(f"Failed to create default patterns: {e}")
    
    def _load_vulnerability_patterns(self) -> Dict:
        patterns_file = os.path.join(
            os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 
            'data', 'vulnerability_patterns.json'
        )
        
        try:
            if os.path.exists(patterns_file):
                with open(patterns_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load vulnerability patterns: {e}")
        
        return {}
    
    def _load_service_vulnerabilities(self) -> Dict:
        # Common service vulnerability mappings
        return {
            21: ['ftp'],      # FTP
            22: ['ssh'],      # SSH
            23: ['telnet'],   # Telnet
            25: ['smtp'],     # SMTP
            53: ['dns'],      # DNS
            80: ['http'],     # HTTP
            110: ['pop3'],    # POP3
            111: ['rpc'],     # RPC
            135: ['rpc'],     # MS RPC
            139: ['smb'],     # NetBIOS
            143: ['imap'],    # IMAP
            161: ['snmp'],    # SNMP
            389: ['ldap'],    # LDAP
            443: ['https', 'ssl'],  # HTTPS
            445: ['smb'],     # SMB
            993: ['imaps', 'ssl'],  # IMAPS
            995: ['pop3s', 'ssl'],  # POP3S
            1433: ['mssql'],  # MSSQL
            3306: ['mysql'],  # MySQL
            3389: ['rdp'],    # RDP
            5432: ['postgresql'],  # PostgreSQL
            5900: ['vnc'],    # VNC
            6379: ['redis'],  # Redis
            8080: ['http'],   # HTTP Alternative
            8443: ['https', 'ssl']   # HTTPS Alternative
        }
    
    def detect_vulnerabilities(self, session_id: str) -> Dict:
        results = {
            'total_vulnerabilities': 0,
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'vulnerabilities': []
        }
        
        try:
            # Get all hosts and ports for this session
            hosts = self.db_manager.get_session_hosts(session_id)
            
            for host in hosts:
                if host['status'] != 'up':
                    continue
                
                ports = self.db_manager.get_host_ports(host['id'])
                
                for port in ports:
                    if port['state'] != 'open':
                        continue
                    
                    # Detect vulnerabilities for this service
                    vulns = self._detect_port_vulnerabilities(host, port)
                    
                    for vuln in vulns:
                        # Add to database
                        vuln_id = self.db_manager.add_vulnerability(
                            host['id'],
                            vuln['title'],
                            vuln['severity'],
                            port_id=port['id'],
                            cve_id=vuln.get('cve_id'),
                            description=vuln.get('description'),
                            cvss_score=vuln.get('cvss_score'),
                            cvss_vector=vuln.get('cvss_vector'),
                            solution=vuln.get('solution'),
                            references=vuln.get('references', [])
                        )
                        
                        if vuln_id:
                            vuln['id'] = vuln_id
                            vuln['host_ip'] = host['ip_address']
                            vuln['port'] = port['port_number']
                            results['vulnerabilities'].append(vuln)
                            
                            # Update counters
                            results['total_vulnerabilities'] += 1
                            severity = vuln['severity'].lower()
                            if severity in results:
                                results[severity] += 1
            
            # Update scan session with vulnerability count
            self.db_manager.update_scan_session(
                session_id, 
                vulnerabilities=results['total_vulnerabilities']
            )
            
            self.logger.info(f"Vulnerability detection completed for session {session_id}: "
                           f"{results['total_vulnerabilities']} vulnerabilities found")
            
        except Exception as e:
            self.logger.error(f"Error during vulnerability detection: {e}")
        
        return results
    
    def _detect_port_vulnerabilities(self, host: Dict, port: Dict) -> List[Dict]:
        vulnerabilities = []
        
        port_num = port['port_number']
        service_name = port.get('service_name', '').lower()
        service_version = port.get('service_version', '')
        service_product = port.get('service_product', '')
        service_fingerprint = f"{service_product} {service_version}".strip()
        
        # Get applicable service types for this port
        service_types = self.service_vulnerabilities.get(port_num, [])
        if service_name and service_name not in service_types:
            service_types.append(service_name)
        
        # Check for vulnerabilities in each applicable service type
        for service_type in service_types:
            if service_type in self.vulnerability_patterns:
                patterns = self.vulnerability_patterns[service_type]
                
                for pattern_def in patterns:
                    vulns = self._check_service_pattern(
                        service_fingerprint, pattern_def, host, port
                    )
                    vulnerabilities.extend(vulns)
        
        # Check for common vulnerabilities based on service banners
        common_vulns = self._check_common_vulnerabilities(service_fingerprint, host, port)
        vulnerabilities.extend(common_vulns)
        
        # Check for SSL/TLS vulnerabilities if applicable
        if port_num in [443, 993, 995, 8443] or 'ssl' in service_name or 'tls' in service_name:
            ssl_vulns = self._check_ssl_vulnerabilities(host, port)
            vulnerabilities.extend(ssl_vulns)
        
        return vulnerabilities
    
    def _check_service_pattern(self, service_fingerprint: str, pattern_def: Dict, 
                              host: Dict, port: Dict) -> List[Dict]:
        vulnerabilities = []
        
        try:
            pattern = pattern_def['pattern']
            match = re.search(pattern, service_fingerprint, re.IGNORECASE)
            
            if not match:
                return vulnerabilities
            
            detected_version = match.group(1)
            version_check = pattern_def.get('version_check', 'version_less_than')
            vulnerable_versions = pattern_def.get('vulnerable_versions', {})
            
            for vuln_version, cve_list in vulnerable_versions.items():
                is_vulnerable = False
                
                if version_check == 'exact_match':
                    is_vulnerable = detected_version == vuln_version
                elif version_check == 'version_less_than':
                    is_vulnerable = self._compare_versions(detected_version, vuln_version) < 0
                elif version_check == 'version_range':
                    is_vulnerable = self._compare_versions(detected_version, vuln_version) <= 0
                
                if is_vulnerable:
                    for cve_id in cve_list:
                        vuln_data = self._get_cve_details(cve_id)
                        if vuln_data:
                            vulnerabilities.append(vuln_data)
        
        except Exception as e:
            self.logger.error(f"Error checking service pattern: {e}")
        
        return vulnerabilities
    
    def _check_common_vulnerabilities(self, service_fingerprint: str, 
                                    host: Dict, port: Dict) -> List[Dict]:
        vulnerabilities = []
        
        # Check for common misconfigurations and known vulnerable services
        fingerprint_lower = service_fingerprint.lower()
        
        # Default credentials checks
        if any(service in fingerprint_lower for service in ['ftp', 'telnet', 'ssh']):
            vulnerabilities.append({
                'cve_id': None,
                'title': 'Potential Default Credentials',
                'description': 'Service may be using default or weak credentials',
                'severity': 'Medium',
                'cvss_score': 5.0,
                'solution': 'Change default credentials and implement strong password policy',
                'references': ['https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication']
            })
        
        # Unencrypted services
        if port['port_number'] in [21, 23, 80, 110, 143] and 'ssl' not in fingerprint_lower:
            vulnerabilities.append({
                'cve_id': None,
                'title': 'Unencrypted Service',
                'description': f'Service on port {port["port_number"]} transmits data in cleartext',
                'severity': 'Low',
                'cvss_score': 2.6,
                'solution': 'Enable SSL/TLS encryption for this service',
                'references': ['https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure']
            })
        
        # Anonymous access checks
        if 'ftp' in fingerprint_lower and 'anonymous' in fingerprint_lower:
            vulnerabilities.append({
                'cve_id': None,
                'title': 'Anonymous FTP Access',
                'description': 'FTP server allows anonymous access',
                'severity': 'Medium',
                'cvss_score': 5.3,
                'solution': 'Disable anonymous FTP access or restrict to read-only',
                'references': ['https://cwe.mitre.org/data/definitions/306.html']
            })
        
        return vulnerabilities
    
    def _check_ssl_vulnerabilities(self, host: Dict, port: Dict) -> List[Dict]:
        vulnerabilities = []
        
        # Common SSL/TLS vulnerabilities based on service versions
        service_info = port.get('service_fingerprint', '').lower()
        
        # Check for known SSL/TLS vulnerabilities
        ssl_vulns = [
            {
                'pattern': r'sslv[23]',
                'title': 'Deprecated SSL Protocol',
                'severity': 'High',
                'cvss_score': 7.4,
                'description': 'Server supports deprecated SSL protocols (SSLv2/SSLv3)',
                'solution': 'Disable SSLv2 and SSLv3, use TLS 1.2 or higher'
            },
            {
                'pattern': r'tls.*1\.0',
                'title': 'Deprecated TLS 1.0',
                'severity': 'Medium',
                'cvss_score': 5.9,
                'description': 'Server supports deprecated TLS 1.0 protocol',
                'solution': 'Disable TLS 1.0, use TLS 1.2 or higher'
            },
            {
                'pattern': r'weak.*cipher',
                'title': 'Weak SSL Ciphers',
                'severity': 'Medium',
                'cvss_score': 5.3,
                'description': 'Server supports weak SSL cipher suites',
                'solution': 'Configure strong cipher suites only'
            }
        ]
        
        for ssl_vuln in ssl_vulns:
            if re.search(ssl_vuln['pattern'], service_info):
                vulnerabilities.append({
                    'cve_id': None,
                    'title': ssl_vuln['title'],
                    'description': ssl_vuln['description'],
                    'severity': ssl_vuln['severity'],
                    'cvss_score': ssl_vuln['cvss_score'],
                    'solution': ssl_vuln['solution'],
                    'references': ['https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration']
                })
        
        return vulnerabilities
    
    def _get_cve_details(self, cve_id: str) -> Optional[Dict]:
        # First check local cache
        cached_data = self.db_manager.get_cached_cve_data(cve_id)
        if cached_data:
            return self._format_vulnerability_data(cached_data)
        
        # If not cached, try to fetch from NIST API
        cve_data = self._fetch_cve_from_api(cve_id)
        if cve_data:
            # Cache the data
            self.db_manager.cache_cve_data(cve_id, cve_data)
            return self._format_vulnerability_data(cve_data)
        
        # If API fails, return basic information
        return {
            'cve_id': cve_id,
            'title': f'Vulnerability {cve_id}',
            'description': f'Known vulnerability {cve_id} detected',
            'severity': 'Medium',
            'cvss_score': 5.0,
            'solution': 'Update to the latest version of the affected software',
            'references': [f'https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}']
        }
    
    def _fetch_cve_from_api(self, cve_id: str) -> Optional[Dict]:
        try:
            # Respect rate limiting
            current_time = time.time()
            if current_time - self.last_api_call < self.api_rate_limit:
                time.sleep(self.api_rate_limit - (current_time - self.last_api_call))
            
            url = f"{self.cve_api_base}?cveId={cve_id}"
            headers = {
                'User-Agent': 'NetHawk-Scanner/1.0',
                'Accept': 'application/json'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            self.last_api_call = time.time()
            
            if response.status_code == 200:
                data = response.json()
                
                if 'vulnerabilities' in data and len(data['vulnerabilities']) > 0:
                    vuln = data['vulnerabilities'][0]['cve']
                    
                    # Extract relevant information
                    description = ''
                    if 'descriptions' in vuln:
                        for desc in vuln['descriptions']:
                            if desc.get('lang') == 'en':
                                description = desc.get('value', '')
                                break
                    
                    cvss_score = 0.0
                    cvss_vector = ''
                    severity = 'Unknown'
                    
                    if 'metrics' in vuln:
                        # Try CVSS v3 first, then v2
                        for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
                            if version in vuln['metrics']:
                                metric = vuln['metrics'][version][0]
                                if 'cvssData' in metric:
                                    cvss_data = metric['cvssData']
                                    cvss_score = cvss_data.get('baseScore', 0.0)
                                    cvss_vector = cvss_data.get('vectorString', '')
                                    
                                    # Determine severity based on score
                                    if cvss_score >= 9.0:
                                        severity = 'Critical'
                                    elif cvss_score >= 7.0:
                                        severity = 'High'
                                    elif cvss_score >= 4.0:
                                        severity = 'Medium'
                                    else:
                                        severity = 'Low'
                                    break
                    
                    # Extract references
                    references = []
                    if 'references' in vuln:
                        for ref in vuln['references'][:5]:  # Limit to 5 references
                            if 'url' in ref:
                                references.append(ref['url'])
                    
                    return {
                        'cve_id': cve_id,
                        'description': description,
                        'severity': severity,
                        'cvss_score': cvss_score,
                        'cvss_vector': cvss_vector,
                        'references': references,
                        'published_date': vuln.get('published', ''),
                        'modified_date': vuln.get('lastModified', '')
                    }
            
        except Exception as e:
            self.logger.warning(f"Failed to fetch CVE {cve_id} from API: {e}")
        
        return None
    
    def _format_vulnerability_data(self, cve_data: Dict) -> Dict:
        return {
            'cve_id': cve_data.get('cve_id'),
            'title': f"CVE-{cve_data.get('cve_id', 'Unknown')}",
            'description': cve_data.get('description', ''),
            'severity': cve_data.get('severity', 'Medium'),
            'cvss_score': cve_data.get('cvss_score', 0.0),
            'cvss_vector': cve_data.get('cvss_vector', ''),
            'solution': 'Update affected software to the latest version',
            'references': cve_data.get('references', [])
        }
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        # Simple version comparison
        try:
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]
            
            # Pad shorter version with zeros
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            
            for i in range(max_len):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1
            
            return 0
        
        except:
            # Fallback to string comparison
            return (version1 > version2) - (version1 < version2)
    
    def get_vulnerability_statistics(self, session_id: str) -> Dict:
        try:
            hosts = self.db_manager.get_session_hosts(session_id)
            stats = {
                'total_vulnerabilities': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'by_host': {},
                'top_vulnerabilities': []
            }
            
            vuln_counts = {}
            
            for host in hosts:
                vulnerabilities = self.db_manager.get_host_vulnerabilities(host['id'])
                host_ip = host['ip_address']
                
                stats['by_host'][host_ip] = {
                    'total': len(vulnerabilities),
                    'critical': 0,
                    'high': 0,
                    'medium': 0,
                    'low': 0
                }
                
                for vuln in vulnerabilities:
                    severity = vuln['severity'].lower()
                    stats['total_vulnerabilities'] += 1
                    
                    if severity in stats:
                        stats[severity] += 1
                        stats['by_host'][host_ip][severity] += 1
                    
                    # Count vulnerability types
                    vuln_title = vuln.get('title', 'Unknown')
                    vuln_counts[vuln_title] = vuln_counts.get(vuln_title, 0) + 1
            
            # Get top vulnerabilities
            stats['top_vulnerabilities'] = sorted(
                vuln_counts.items(), 
                key=lambda x: x[1], 
                reverse=True
            )[:10]
            
            return stats
        
        except Exception as e:
            self.logger.error(f"Error getting vulnerability statistics: {e}")
            return {}
    
    def export_vulnerabilities(self, session_id: str, format: str = 'json') -> str:
        try:
            hosts = self.db_manager.get_session_hosts(session_id)
            export_data = {
                'session_id': session_id,
                'export_time': datetime.now().isoformat(),
                'vulnerabilities': []
            }
            
            for host in hosts:
                vulnerabilities = self.db_manager.get_host_vulnerabilities(host['id'])
                
                for vuln in vulnerabilities:
                    export_data['vulnerabilities'].append({
                        'host_ip': host['ip_address'],
                        'hostname': host.get('hostname'),
                        'cve_id': vuln.get('cve_id'),
                        'title': vuln.get('title'),
                        'description': vuln.get('description'),
                        'severity': vuln.get('severity'),
                        'cvss_score': vuln.get('cvss_score'),
                        'solution': vuln.get('solution'),
                        'detected_at': vuln.get('detected_at')
                    })
            
            if format.lower() == 'json':
                return json.dumps(export_data, indent=2)
            elif format.lower() == 'csv':
                import csv
                import io
                
                output = io.StringIO()
                writer = csv.writer(output)
                
                # Write header
                writer.writerow([
                    'Host IP', 'Hostname', 'CVE ID', 'Title', 'Severity', 
                    'CVSS Score', 'Description', 'Solution', 'Detected At'
                ])
                
                # Write data
                for vuln in export_data['vulnerabilities']:
                    writer.writerow([
                        vuln.get('host_ip', ''),
                        vuln.get('hostname', ''),
                        vuln.get('cve_id', ''),
                        vuln.get('title', ''),
                        vuln.get('severity', ''),
                        vuln.get('cvss_score', ''),
                        vuln.get('description', ''),
                        vuln.get('solution', ''),
                        vuln.get('detected_at', '')
                    ])
                
                return output.getvalue()
            
        except Exception as e:
            self.logger.error(f"Error exporting vulnerabilities: {e}")
            return ""